package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"net/http"
	"strconv"
)

// DAO - DATA ACCESS OBJECT (USED TO COMMUNICATE WITH DATABASE)
type Exchange struct {
	gorm.Model
	Amount float64
	From   string
	To     string
	Rate   float64
}

// DTO - DATA TRANSFER OBJECT (USED TO PROCESS REQUEST)

type ExchangeResponse struct {
	ValorConvertido string
	SimboloMoeda    string
}

type ExchangeDTO struct {
	Amount float64
	From   string
	To     string
	Rate   float64
}

func NewExchangeDTO(amount float64, from string, to string, rate float64) *ExchangeDTO {
	return &ExchangeDTO{amount, from, to, rate}
}

type ExchangeError struct {
	Type string
}

func (e *ExchangeError) Error() string {
	return e.Type
}

func NewExchangeDTOFromParams(c *gin.Context) (*ExchangeDTO, *ExchangeError) {
	a, amount_err := strconv.ParseFloat(c.Param("amount"), 64)
	if amount_err != nil {
		return nil, &ExchangeError{Type: "PARSING AMOUNT ERROR"}
	}
	r, rate_err := strconv.ParseFloat(c.Param("rate"), 64)
	if rate_err != nil {
		return nil, &ExchangeError{Type: "PARSING RATE ERROR"}
	}
	return NewExchangeDTO(a, c.Param("from"), c.Param("to"), r), nil
}

//func exchange(c *gin.Context) {
//	excg, err := NewExchangeDTOFromParams(c)
//	if err != nil {
//		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
//			"error": err.Type,
//		})
//	} else {
//		c.JSON(http.StatusOK, gin.H{
//			"amout": excg.Amount,
//			"from":  excg.From,
//			"to":    excg.To,
//			"rate":  excg.Rate,
//		})
//
//	}
//}

//func saveExchange(db *gorm.DB) {
//	db.Create(&Exchange{Amount: 420.69, From: "BRL", To: "USD", Rate: 69.69})
//	db.Create(&Exchange{Amount: 0.69, From: "USD", To: "EUR", Rate: 1.69})
//}

func Migrate(db *gorm.DB) {
	db.AutoMigrate(&ExchangeResponse{})
}

type ExchangeResponseRepository interface {
	StoreExchangeResponse(ecr *ExchangeResponse)
}

type ExchangeResponseRepositoryImpl struct {
	db *gorm.DB
}

func NewExchangeResponseRepositoryImpl(db *gorm.DB) *ExchangeResponseRepositoryImpl {
	return &ExchangeResponseRepositoryImpl{db}
}

func (repo *ExchangeResponseRepositoryImpl) StoreExchangeResponse(ecr *ExchangeResponse) {
	repo.db.Create(ecr)
}

type ExchangeService interface {
	StoreExchangeResponse(exc *ExchangeDTO) (*ExchangeResponse, *ExchangeError)
}

type ExchangeServiceImpl struct {
	repo ExchangeResponseRepository
}

func (esi *ExchangeServiceImpl) storeExchangeResponse(exc *ExchangeDTO) (*ExchangeResponse, *ExchangeError) {
	fmt.Print("NOT IMPLEMENTED:  ExchangeServiceImpl storeExchangeResponse")
	esi.repo.StoreExchangeResponse(&ExchangeResponse{
		ValorConvertido: "VALOR CONVERTIDO",
		SimboloMoeda:    "SimboloMoeda",
	})
	return nil, nil
}

func NewEchangeServiceImpl(repo ExchangeResponseRepository) *ExchangeServiceImpl {
	return &ExchangeServiceImpl{repo}
}

type ExchangeController struct {
	router          *gin.Engine
	exchangeService *ExchangeService
}

func NewExchangeController(router *gin.Engine, exchangeService *ExchangeService) *ExchangeController {
	return &ExchangeController{router, exchangeService}
}

func (ec *ExchangeController) storeExchangeResponse(c *gin.Context) {
	excg, err := NewExchangeDTOFromParams(c)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
			"error": err.Type,
		})
	} else {
		c.JSON(http.StatusOK, gin.H{
			"amout": excg.Amount,
			"from":  excg.From,
			"to":    excg.To,
			"rate":  excg.Rate,
		})

	}

}

func (ec *ExchangeController) mountRoutes() {
	ec.router.GET("/exchange/:amount/:from/:to/:rate", ec.storeExchangeResponse)
}

func main() {
	r := gin.Default()
	dsn := "admin:dora2012@tcp(127.0.0.1:3306)/golang_test?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})

	if err != nil {
		fmt.Print("FUCK SOMETHING WENT WRONG")
		return
	}

	exchangeResponseRepo := NewExchangeResponseRepositoryImpl(db)
	// SERVICES
	exchangeService := NewEchangeServiceImpl()

	exchangeController := NewExchangeController(r)

	Migrate(db)

	//saveExchange(db)

	r.Run()

}
